# 海戦ゲーム

実作業期間：3ヶ月半

制作時期：平成27年8月中旬頃から 

## このゲームについて
このゲームのベースはボードゲーム「海戦ゲーム」になっています。  
対戦をPC間の通信で表現しようと思い、Winsock2を用いています。  
個人製作なので、全てのソースファイルは私が担当しています。ソースはゲームメインとライブラリで分けています。  
ゲーム内で使用している画素材は版権フリーのもの以外は私が自分で作成したものです。  
今まで作ったゲームの中で一番工夫が多く、ユーザーを意識して作った自信があります。

## 工夫した箇所
### 1. ライブラリの修正
「[2D3D対応自作ライブラリ](https://github.com/human-osaka-game-2013/Library)」を修正しました。  
具体的にはDirect3Dや描画や入力デバイスが通常変数としてメイン関数内で宣言されていた所をデバイスクラス「device.h」としてまとめ、このライブラリでは基本的なサブルーチンをシーン管理クラス「SceneManage.h」で統括しているため、デバイスクラスオブジェクトをシーン管理クラスに包含させました。  
そしてシーン管理クラスから各シーン基底クラス「SceneInterface.h」へconstポインタとして渡しています。  
以前はシーン管理クラスとシーン基底クラスをすべてライブラリとして含めていましたが、ゲームメイン側で指定するものだと考え直し、ゲームメイン側ブロジェクトにインターフェースとして変更しました。  
（「SceneInterface.h」「SceneManagerInterface.cpp」）

### 2. ポリモーフィズムを意識した設計
上記のデバイスクラスでも意識していましたが、ゲームメインの所でもポリモーフィズムを意識して、ゲーム内のオブジェクトクラスを考えています。戦闘シーン内では駒配置や攻撃などをステートパターンで設計しています。

### 3. UIに配慮
2Dのシミュレーションゲームという事で、出来るだけユーザーに進行状況を理解してもらえるよう、攻撃先や移動先などがひと目見て分かるように表示し、ユーザーが次に何をすればいいかをログ方式で表示させました。

### 4. 通信部分
TCP/IPで通信する際に、通信を始めた後に相手から送られてくるデータを受け取る時、ゲームが止まらないようにノンブロッキング方式を用いて、ゲーム内のループ（主に描画）処理をさせています。何度もデータを送りつけても駄目なので、その辺りの制御も頑張りました。

### 5. やりこみ要素
戦闘中の攻撃の命中率や被弾状況から判定を取って、条件を満たした場合に「勲章」がアンロック出来る要素を実装しています。セーブにも対応しています。

## 操作説明
### タイトル
基本マウス操作になります  
「START」をクリックするとゲームが始まります。  
「REWARD」をクリックすると獲得した勲章の一覧を観覧できます。  
右下にあるボックスは通信設定です。  
自身がサーバー側になる場合は「SERVER」ボタンを押し、ポート番号の入力をして、「UPDATE」ボタンを押下してください。（IPアドレスは不要です）  
自身がクライアント側になる場合は「CLIENT」ボタンを押し、サーバー側のIPアドレスとポート番号を入力してから、「UPDATE」ボタンを押下してください。  
※初回接続時はファイアーウォールの関係上、デバイスロスト未対応のため再起動が必要の場合があります。  
IPアドレスを入力しない場合は警告は出る場合はありますが、デフォルトでローカルアドレスのパスが登録されます。  
アドレスが正しくないor対戦相手が接続してこない場合はゲームを再起動する必要があります。

### 戦闘中
基本画面下部のログに従ったマウス操作になります。  
- 右クリック  
（駒の配置時）駒の回転、（移動を選択した場合の）行動キャンセル  
- 左クリック  
駒の配置、行動選択など

ゲームの流れは、駒の配置→行動の選択→戦闘結果→（勝敗が決まっていなければ）行動の選択へとなっており、行動選択の順番は空母→戦艦→巡洋艦→駆逐艦→潜水艦→空母（以下ループ）です。  
このループが一周するとひとつのターンが終了したことになります。

勝敗が決まった場合は（引き分けor勝利の場合）獲得した勲章一覧が表示されます。

その場合は勲章一覧を閉じ、ログの指示通り左クリックを押すとタイトルに戻ります。
